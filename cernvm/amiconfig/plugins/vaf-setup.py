#
# vaf-setup.py -- by Dario Berzano <dario.berzano@cern.ch>
#
# Plugin for amiconfig for configuring the Virtual Analysis Facility.
#
# See: https://github.com/dberzano/virtual-analysis-facility
#

import os
import pwd
import string
import time
import socket
import re

from amiconfig.errors import *
from amiconfig.lib import util
from amiconfig.plugin import AMIPlugin

class AMIConfigPlugin(AMIPlugin):

    # Name of this plugin
    name = 'vaf-setup'

    # Where is sshcertauth? Usually on cvmfs
    sshcertauth_src = '/cvmfs/sft.cern.ch/lcg/dev/cvmvaf/sshcertauth'

    # Where to install (i.e. symlink) sshcertauth
    sshcertauth_dst = '/var/www/html/auth'

    # Where to create the config file of sshcertauth
    sshcertauth_conf = '/etc/sshcertauth/conf.php'

    # Directory of the authorized public keys
    auth_keys_dir = '/etc/ssh/authorized_keys_globus'

    # The pool_users plugin requires a mapfile
    auth_mapfile = '/etc/sshcertauth-x509-map'

    # User of apache2 (httpd)
    httpd_user = 'apache'

    # Automatically generated configuration for httpd
    httpd_ssl_conf = '/etc/httpd/conf.d/ssl.conf'

    # Where to store the host certificate and private key
    ssl_dir = '/etc/grid-security'

    # crontab file for purging expired keys
    cron_expiry = '/etc/cron.d/sshcertauth'

    # sshd configuration
    sshd_conf = '/etc/ssh/sshd_config'

    # The sudoers file
    sudoers = '/etc/sudoers'

    # Configuration for sssd
    sssd_conf = '/etc/sssd/sssd.conf'

    # Configuration for nscd
    nscd_conf = '/etc/nscd.conf'


    def configure(self):
        """
        [vaf-setup]
        client_settings=alice
        node_type=[master|slave]  # defaults to slave
        auth_method=[alice_ldap|pool_users|<none>]  # defaults to none
        num_pool_accounts=50  # must be specified if auth_method==pool_users
        """

        cfgraw = self.ud.getSection('vaf-setup')

        #
        # Authentication method validation
        #

        if 'auth_method' in cfgraw:
            auth_method = cfgraw['auth_method']
            if auth_method == 'pool_users':
                if 'num_pool_accounts' in cfgraw:
                    try:
                        num_pool_accounts = int(cfgraw['num_pool_accounts'])
                        if num_pool_accounts <= 1:
                            raise ValueError('')
                    except ValueError as e:
                        # Fatal
                        print "Invalid number of pool accounts: %s" % cfgraw['num_pool_accounts']
                        return
                else:
                    # Fatal
                    print "No number of pool accounts specified"
                    return
            elif auth_method == 'alice_ldap':
                num_pool_accounts = 0  # unused
            else:
                # Fatal
                print "Unknown authentication method: %s" % auth_method
                return
        else:
            # No authentication method specified: don't config sshcertauth
            auth_method = None

        if 'node_type' in cfgraw and cfgraw['node_type'] == 'master' and auth_method is not None:

            #
            # Configure sshcertauth
            #

            # Parent creation
            parent = os.path.dirname( self.sshcertauth_dst )
            if not os.path.isdir(parent):
                try:
                    os.makedirs(parent, 0755)
                except os.error as e:
                    print "Cannot create directory %s: %s" % (parent, e)

            # Symlink
            try:
                if os.path.islink( self.sshcertauth_dst ):
                    os.unlink( self.sshcertauth_dst )
                os.symlink(self.sshcertauth_src, self.sshcertauth_dst)
            except os.error as e:
                print "Cannot create symbolic link %s: %s" % (self.sshcertauth_dst, e)
                return

            # Create the configuration file for sshcertauth
            parent = os.path.dirname(self.sshcertauth_conf)
            try:
                os.mkdir(parent, 0755)
            except os.error as e:
                pass

            try:
                f = open( self.sshcertauth_conf, 'w' )
                lines = [
                    '<?php',
                    '# Automatically generated by the vaf-setup plugin of amiconfig',
                    '# Generated at %s' % (time.strftime('%Y-%m-%d %H:%M:%S %z')),
                    '$$sshPort = 22;',
                    '$$sshKeyDir = "${AUTH_KEYS_DIR}";',
                    '$$maxValiditySecs = 43200;',
                    '$$pluginUser = "${AUTH_METHOD}";',
                    '$$opensslBin = "openssl";',
                    '$$mapFile = "${AUTH_MAPFILE}";',
                    '$$mapValiditySecs = 172800;',
                    '$$mapIdLow = 1;',
                    '$$mapIdHi = ${NUM_POOL_ACCOUNTS};',
                    '$$mapUserFormat = "pool%03u";',
                    '?>' ]
                for l in lines:
                    f.write( string.Template(l).substitute({
                        'AUTH_KEYS_DIR': self.auth_keys_dir,
                        'AUTH_METHOD': auth_method,
                        'AUTH_MAPFILE': self.auth_mapfile,
                        'NUM_POOL_ACCOUNTS': num_pool_accounts
                    }) )
                    f.write('\n')
                f.close()

            except IOError as e:
                print "Cannot write configuration %s: %s" % (self.sshcertauth_conf, e)
                return

            # Mapfile with appropriate permissions (rw for httpd user)
            if not os.path.isfile(self.auth_mapfile):
                try:
                    f = open(self.auth_mapfile, 'w')
                except IOError as e:
                    print "Cannot create mapfile %s: %s" % (self.auth_mapfile, e)
                    return
            try:
                httpd_uid = pwd.getpwnam(self.httpd_user).pw_uid
            except KeyError:
                print 'Cannot find user %s' % self.httpd_user
                return

            try:
                os.chown(self.auth_mapfile, httpd_uid, -1)
                os.chmod(self.auth_mapfile, 0600)
            except OSError as e:
                print 'Cannot chown/chmod %s: %s' % (self.auth_mapfile, e)
                return

            # Create the configuration file for apache2 (TODO: improve)
            try:
                f = open(self.httpd_ssl_conf, 'w')
                f.write("""
LoadModule ssl_module modules/mod_ssl.so
Listen 443
AddType application/x-x509-ca-cert .crt
AddType application/x-pkcs7-crl .crl
SSLPassPhraseDialog builtin
SSLSessionCache shmcb:/var/cache/mod_ssl/scache(512000)
SSLSessionCacheTimeout 300
SSLMutex default
SSLRandomSeed startup file:/dev/urandom 256
SSLRandomSeed connect builtin
SSLCryptoDevice builtin
<VirtualHost _default_:443>
ErrorLog logs/ssl_error_log
TransferLog logs/ssl_access_log
LogLevel warn
SSLEngine on
SSLProtocol all -SSLv2
SSLCipherSuite ALL:!ADH:!EXPORT:!SSLv2:RC4+RSA:+HIGH:+MEDIUM:+LOW
<Files ~ "\.(cgi|shtml|phtml|php3?)$">
    SSLOptions +StdEnvVars
</Files>
<Directory "/var/www/cgi-bin">
    SSLOptions +StdEnvVars
</Directory>
SetEnvIf User-Agent ".*MSIE.*" \\
         nokeepalive ssl-unclean-shutdown \\
         downgrade-1.0 force-response-1.0
CustomLog logs/ssl_request_log \\
          "%t %h %{SSL_PROTOCOL}x %{SSL_CIPHER}x \\"%r\\" %b"
### Customized for sshcertauth ###
SSLCertificateFile /etc/grid-security/hostcert.pem
SSLCertificateKeyFile /etc/grid-security/hostkey.pem
#SSLCACertificatePath /cvmfs/alice.cern.ch/x86_64-2.6-gnu-4.1.2/Packages/AliEn/v2-19/api/share/certificates
SSLCACertificatePath /cvmfs/atlas.cern.ch/repo/ATLASLocalRootBase/etc/grid-security/certificates
SSLVerifyDepth 10
<Directory /var/www/html/auth>
  SSLVerifyClient require
  SSLOptions +StdEnvVars +ExportCertData
  AllowOverride all
</Directory>
</VirtualHost>
""")
                f.close()
            except IOError as e:
                print 'Cannot write %s: %s' % (self.httpd_ssl_conf, e)

            # Create a new self-signed certificate
            try:
                os.mkdir(self.ssl_dir, 0755)
            except os.error:
                pass

            my_ipv4 = self.get_ipv4()
            r = os.system( string.Template('openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 ' +
                '-subj "/CN=${MY_IPV4}" ' +
                '-keyout ${SSL_DIR}/hostkey.pem ' +
                '-out ${SSL_DIR}/hostcert.pem').substitute({
                    'SSL_DIR': self.ssl_dir,
                    'MY_IPV4': my_ipv4
                }) )
            if r != 0:
                print 'Error generating certificate and keys'
                return

            try:
                os.chmod(self.ssl_dir + '/hostcert.pem', 0444)
                os.chmod(self.ssl_dir + '/hostkey.pem', 0400)
            except os.error:
                print 'Cannot change mode of certificate/key'
                return

            # Enable keys expiration
            try:
                f = open(self.cron_expiry, 'w')
                f.write('*/5 * * * * root /var/www/html/auth/keys_keeper.sh expiry\n')
                f.close()
            except IOError as e:
                print 'Cannot write %s: %s' % (self.cron_expiry, e)

            # Authorized keys path for SSH
            try:
                os.mkdir(self.auth_keys_dir)
                # Preserve authorized keys for root
                root_key = '/root/.ssh/authorized_keys'
                if os.path.isfile(root_key):
                    os.symlink(root_key, self.auth_keys_dir + '/root')
            except os.error:
                pass

            try:
                f = open(self.sshd_conf, 'r')
                lines = f.readlines()
                f.close()
                reauth = r'^[ \t]*AuthorizedKeysFile'
                f = open(self.sshd_conf, 'w')
                for l in lines:
                    if not re.match(reauth, l):
                        f.write(l)
                f.write( 'AuthorizedKeysFile %s/%%u\n' % self.auth_keys_dir )
                f.close()
            except IOError as e:
                print 'Problem configuring %s: %s' % (self.sshd_conf, e)

            # sudoers
            try:
                f = open(self.sudoers, 'r')
                lines = f.readlines()
                f.close()
                rek = r'.*keys_keeper\.sh'
                f = open(self.sudoers, 'w')
                for l in lines:
                    if not re.match(rek, l):
                        f.write(l)
                f.write('Defaults!%s/keys_keeper.sh !requiretty\n' % self.sshcertauth_dst)
                f.write('apache ALL=(ALL) NOPASSWD: %s/keys_keeper.sh\n' % self.sshcertauth_dst)
                f.close()
            except IOError as e:
                print 'Problem configuring %s: %s' % (self.sshd_conf, e)

            # Restart affected services
            os.system("/sbin/service sshd restart")
            os.system("/sbin/service httpd restart")

            ## end of sshcertauth ##

        if auth_method == 'pool_users':

            # Create pool accounts
            os.system("groupadd -g 50000 pool")
            for i in range(1, num_pool_accounts+1):
                os.system("adduser pool%03u -s /bin/bash -u %u -g 50000" % (i, 50000+i))

        elif auth_method == 'alice_ldap':

            # Create special 'alice' group
            os.system('groupadd -g 1395 alice')

            # Configuring SSSD
            try:
                f = open(self.sssd_conf, 'w')
                f.write("""
[sssd]
config_file_version = 2
services = nss, pam
domains = default

[nss]
filter_users = root,ldap,named,avahi,haldaemon,dbus,radiusd,news,nscd
override_shell = /bin/bash
override_homedir = /home/%u
#override_gid = 99

[pam]

[domain/default]
ldap_tls_reqcert = never
auth_provider = ldap
ldap_schema = rfc2307bis
ldap_search_base = ou=People,o=alice,dc=cern,dc=ch
ldap_group_member = uniquemember
id_provider = ldap
ldap_id_use_start_tls = False
ldap_uri = ldap://aliendb06a.cern.ch:8389/
cache_credentials = True
ldap_tls_cacertdir = /etc/openldap/cacerts
entry_cache_timeout = 600
ldap_network_timeout = 3
ldap_access_filter = (objectclass=posixaccount)
ldap_user_uid_number = CCID
""")
                f.close()
            except IOError as e:
                print 'Cannot write SSSD configuration %s: %s' % (self.sssd_conf, e)
                return

            # Mode
            try:
                os.chmod(self.sssd_conf, 0600)
            except os.error:
                print 'Cannot change permissions of %s' % self.sssd_conf
                return

            # Enable auth options: notably, sssd (for LDAP) and mkhomedir
            r = os.system('authconfig --enablesssd --enablesssdauth ' +
                '--enablelocauthorize --enablemkhomedir --update')
            if r != 0:
                print 'Cannot enable authentication mechanism'
                return

            # Restart sssd
            os.system("/sbin/chkconfig sssd on")
            os.system("/sbin/service sssd restart")

            # Disable nscd cache on users and groups: sssd has its own
            try:
                f = open(self.nscd_conf, 'r')
                lines = f.readlines()
                f.close()
                recache = r'^[ \t]*enable-cache[ \t]+(group|passwd)[ \t]+.*$'
                f = open(self.nscd_conf, 'w')
                for l in lines:
                    if not re.match(recache, l):
                        f.write(l)
                f.write('enable-cache passwd no\n')
                f.write('enable-cache group no\n')
                f.close()
            except IOError as e:
                print 'Problem configuring %s: %s' % (self.sshd_conf, e)

            # Clean nscd caches and reload configuration
            os.system("/sbin/service nscd reload")
            os.system("/sbin/service nscd restart")

            # Hook in rc.local to fix auth_keys_dir permission messed up by
            # cloud-init --> should be no longer needed

        print '*** EXECUTED OK ***'


    def get_ipv4(self):
      try:
        # No data is actually transmitted (UDP)
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect( ('8.8.8.8', 53) )
        real_ip = s.getsockname()[0]
        s.close()
        return real_ip
      except socket.error as e:
        print "Cannot retrieve current IPv4 address: %s" % e
        return
